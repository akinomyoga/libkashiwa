# -*- coding: utf-8; fill-column: 79 -*-

-------------------------------------------------------------------------------
  概要
-------------------------------------------------------------------------------

Title: kashiwa library
Author: K. Murase <myoga.murase@gmail.com>

他で必要になった数値計算関連のコードを放り込んでおく場所。


-------------------------------------------------------------------------------
  Note
-------------------------------------------------------------------------------

目次 (詳細な内容は Done を参照)

* [2017-02-05] big_integer: 基数は 10 の累乗よりも 2 の累乗の方が良い。


-------------------------------------------------------------------------------
  ToDo
-------------------------------------------------------------------------------

2024-07-12

* contour: 次に考えるべきは resampling ではないか

  具体的に contour の上で何か評価をしようと思ったら例えば t などで parametrize
  して任意の t に対して滑らかに正しい位置を返す関数が欲しくなる。

  * 端点から端点がほぼ直線的に繋がっている場合は問題ない。

  * 途中で鋭角で折れ曲がっている時にどうするか? 例えば inchworm 的な方法で繋ご
    うと考えるとまた無限ループに陥ってしまう。或いはもっと別の parametrization
    を考える?

  * 更に現在のセルの中で連続的に繋がっていない場合にはどうするか? セルの外側に
    はみでても追跡するとしたとしても、実際にはそもそもどうやっても繋がっていな
    いという場合も考えられる。その場合にはそもそも contour として繋ぐ事もできな
    い。

  という事を考えるとそもそも原理的にちゃんと繋ぐことができるかどうかは保証され
  ていない。ちゃんと繋ぐ事ができるのは曲線が十分に滑らかでセルの分割が曲線の構
  造を捉えられるぐらいに小さくなっている時のみである。

2024-07-11

* contour: trace_contour_grid, Newton 法による高速化

2017-02-12

* big_integer: より良い計算方法

  - 掛け算: Karatsuba, etc.
  - 割り算: ニュートン法, etc.
  - 基数変換: Karatsuba, etc.

2017-02-03

* ksh/checked.h: overflow を検知して整数の演算を行うクラス?

2017-01-06

* Gauss-Legendre

  取り敢えず多倍長演算を使わずに係数を計算するというのでも良いのではないか。
  丸め誤差などが問題になるだろうが丸め誤差の範囲では問題なくできるだろう。

  係数を計算する為には先ず Legendre 多項式を生成して、
  更にその零点を見つけていく必要がある。
  Legendre 多項式の係数は一般に有理数になる。
  有理係数の多項式を実装するか、或いは分母は別に管理するかで取り扱う。
  分母を別に取り扱うとしても結局多項式同士の加算をする際には
  特別な処置が必要になるのではないかと思われる。
  或いは直接係数を計算してしまえば良いのだろうか。

2016-12-16

* ガウス求積: 次数を動的に指定できる様にした方が良い

  というのも実際の所、次数に応じた係数の計算はそんなに時間がかかるものではない筈だからである。
  もし気になるのであれば事前に巨大な表を生成してバイナリに埋め込んでおく事もできる。

  但し何れにしても各次数に応じた係数を計算するためには多倍長の計算が必要である。
  多倍長の実装が終わるまではガウス求積は現在持っている表に従った物を使うしかない。


2016-12-13

* 今必要な物・今後必要になる物

  > - 線形フィッティング用のコード

  - ベクトル場の積分曲線を作ること
    これは Runge-Kutta を利用する
    これは比較的自明なのでわざわざ libkashiwa の方で用意する物でもない気がする。

  - 多倍長演算
  - Gauss-Legendre quadrature 高精度版

  - 補間 (スプライン補間、チェビシェフ補間など)
    高速化の為の補間の場合には誤差評価もできる様にする。
    これは hydro2jam で使った物を移植してくれば良い。


-------------------------------------------------------------------------------
  Done
-------------------------------------------------------------------------------

2024-07-18

* contour: やはり単連結でない場合の取りこぼしが問題になっている [#D0021]

  tracer_grid の場合には全ての領域を跨ぐリンクについて少なくとも1回は等高線が通
  過したという事を判定する。現在は連結成分毎に境界を生成しているが、寧ろリンク
  毎に mark をつけて行くのが良い。

  実装した。femtoscopy-note/schro で試した限り安定して動いている。

2024-07-11

* contour: 一つの点から複数の等高線が出ている場合の問題 [#D0020]

  次の線素をどの様に選ぶべきだろうか。現在の方針だと直進を好む様にしている。然
  しこれだと複数の稜線が出ている場合に正しく経路を取り尽くす事ができない。

  a reject: 角度をもっと細かく取って隣の等高線を決定しようとしたが振動が起きて
    駄目だった。

    // determine_angle_scope (src/ksh/contour.hpp)

    constexpr int angle_sample_count = 100;
    // To handle the higher-order critical points from which more than two
    // contours come out, we try to select the next contour properly.

    // I first tried to switch the rotation direction based on whether the
    // region is in the right-hand side with respect to the previous direction,
    // i.e., we always select the next contour in the outward direction.  This
    // turned out to cause the oscillation.
    double const dtheta = 2.0 * M_PI / angle_sample_count;
    if (!is_in_region(z + n * std::polar(ds, 0.5 * theta1))) {
      for (int i = 1; i < angle_sample_count; i++) {
        double const theta2 = (i + 0.5) * dtheta;
        if (this->is_in_region(z + n * std::polar(ds, theta2)))
          return {theta2 - dtheta, theta2};
      }
    } else if (!is_in_region(z + n * std::polar(ds, -0.5 * theta1))) {
      for (int i = 1; i < angle_sample_count; i++) {
        double const theta2 = -(i + 0.5) * dtheta;
        if (this->is_in_region(z + n * std::polar(ds, theta2)))
          return {theta2, theta2 + dtheta};
      }
    }

  b reject: a の方法で隣の等高線を決める時に回転方向を、範囲の外側に出る方向に
    決定しようとしていたのがいけないのかもしれないと思って、範囲の向きに関係な
    く反時計回りに回転して探索する様にしたが、それでもやはり振動が起きる。

  改めて考えてみたが何故振動が発生するのかよく分からない。もしくは、直進できる
  かの探索と細かい探索で探索半径 ds を変更する? 小さな半径で探して非自明な向き
  に等高線が出ていたらそちらに進む。こうすれば隣の別の等高線に引っかかってしま
  うという事はない気がする。

  c reject: 折れ曲がり判定に使う半径は小さくする?

    これを試してみたらうまく行ったと思ったが実はコードが有効になっていなかった。
    有効にすると失敗する。何故なら小さな半径で二つの角度で片方だけが領域に入る
    様にしても、大きな半径ではそうとは限らないので。然し、だからと言って小さな
    半径で step を踏む様にするとそれは結局小さな ds で実行するのと変わらないの
    で意味ない。

    // D0020: To properly handle critical points at which multiple contours
    // cross, we first scan [0, 2\pi) with some sampling points.  We use a
    // smaller radius $ds2 = (2.0/3.0)ds$ to avoid oscillation (infinite loop)
    // near the sharp angle of the region.
    {
      constexpr int angle_sample_count = 12;
      double const dtheta = 2.0 * M_PI / angle_sample_count;
      double const ds2 = (2.0 / 3.0) * ds;
      double const theta1 = 0.5 * dtheta;
      bool const theta1_in_region = is_in_region(z + n * std::polar(ds2, theta1));
      for (int i = 1; i < angle_sample_count; i++) {
        double const theta2 = (i + 0.5) * dtheta;
        if (this->is_in_region(z + n * std::polar(ds2, theta2)) != theta1_in_region)
          return {theta2 - dtheta, theta2};
      }
    }

  うーん。やはり何故 b でうまく行かないのかが分からない。うーん。分かった気がす
  る。鋭角付近でもう一つの辺に移る時には必ずしも直角に折れ曲がる訳では無い。鋭
  角に折れ曲がる事ができたとすると、元の辺との交点が二つあって、そうするとその
  次の試行で必ず元の辺に戻ってしまう? という事の気がする。

  * 振動を抑えるにはやはり contour の方向性をちゃんと決める様にするべき
    の気がする。今のコードを見ると最初の線素は右手に領域を囲む様になっている。
    これは余り自然ではない気がするので、取り敢えず逆向きにしたい。

    と思ったがこれを方向性を決めたとしてもやはり振動は抑えられない気がする。コー
    ドはより単純になるかもしれないが現在の問題とは独立の話である。

    // D0020: To properly handle critical points at which multiple contours
    // cross, we first scan [0, 2\pi) with some sampling points.
    {
      constexpr int angle_sample_count = 12;
      double const dtheta = 2.0 * M_PI / angle_sample_count;

      // We first determine a small angle $\theta$ outside the region.  We
      // should be able to find such an angle in the clockwise direction
      // because we trace the contour so that it encloses the region on the
      // left-hand side.
      int count = 0;
      double theta = 0.5 * dtheta;
      while (is_in_region(z + n * std::polar(ds, theta))) {
        theta *= 0.5;
        if (++count >= 20)
          throw std::runtime_error("binary_search: wrong boundary direction");
      }

      // We then increase $\theta$ by $d\theta$ and find the first $\theta$ in
      // the region.
      for (int i = 1; i < angle_sample_count; i++) {
        theta += dtheta;
        if (this->is_in_region(z + n * std::polar(ds, theta)))
          return {theta - dtheta, theta};
      }
    }

  次の可能性としては既に通った道を覚えておいてその道は通らない様にするという物。
  しかしこれの判定も難しい様な気がする。物凄く鋭角になっていたり、細い隙間がずっ
  と続いている様な状況だと物凄く昔の線素とも交差する可能性があるので結局全ての
  線素と衝突判定をしなければならず O(N^2) になる。時間計算量を忘れる事にしても、
  交差判定自体をどの様に行うかも問題がある。

  d 或いは諦めて格子ベースで点を特定してその後で点を適当に並べ替えるという方法
    にする?

    x ok: 然しそうだとしても複数の線が格子の辺を跨いでいる時にそれらを正しく抽
      出できるのかという問題がある。

      或いは実は大丈夫なのだろうか。例えば偶数個の交差は見逃す可能性がある。然
      し、そういう事ならば別に偶数個の交差は省略しても良いのでは? 例えば以下の
      様になっていた場合 (格子点は * で示してある) には、真ん中の格子セルについ
      ては交差が一つも検出されない。

      >     |........|
      >  *  |.*....*.|  *
      >     +--------+
      > 
      >     +--------+
      >  *  |.*....*.|  *
      >     |........|

      そうすると形状的に以下の形になっていると錯誤してしまう。

      >     |........|
      >  *  |.*....*.|  *
      >     |........|
      >     |........|
      >     |........|
      >  *  |.*....*.|  *
      >     |........|

      然し改めて考えてみると実はこれで問題ない様な気がする。

    x ok: 全部列挙できたとしてもそれぞれの点がどの様に繋がっているかをどうやっ
      て決めるのか? と思ったが、それに関しては問題ない様な気がしてきた。単に隣
      り合うもの同士で組にすれば良いのでは。

    うーん。これだと完全に実装し直しになってしまう。

    どの様に実装したらよいだろうか。現在の点を分類してそれ毎に処理を切り替えれ
    ば良い? 探索範囲の境界については特別に取り扱う必要がある気がする → 実装し
    た。これにより病的な振る舞いは排除することができたと思う。一方で失敗してい
    る気がする。

  取り敢えずこれは安定して動作している。

2017-02-12

* [2017-02-03] polynomial: 割り算 (商と余り) [#D0019]

  現在は係数体による割り算は提供しているが、
  多項式の割り算については提供していない。
  →取り敢えず簡単な方法で実装した。恐らく Knuth の方法と呼ばれる物。

2017-02-05 Memo

* big_integer: 基数は 10 の累乗よりも 2 の累乗の方が良い [#D0018]

  十進整数としての出力の際の基数の変換に時間がかかるからと言って
  基数を初めから 10 の累乗にして計算してみた。
  結果、本体の計算自体に基数の変換よりもずっと時間がかかる様になった。
  つまり、やはり計算は 2 の累乗の基数で行った方が圧倒的に速い。
  これは mod がシフトで済んでいたのが割り算になってしまうからだと思われる。

2017-02-04

* polynomial, rational: a = -a 最適化 [#D0017]

  操作 a = -a については型によって効率の良い実装方法がある筈。

  → ksh/def.h に kashiwa::destructive_negate を用意した。

* polynomial, rational: 共通の演算子について自動で定義する方法を考える [#D0016]

* polynomial, rational: K overloads [#D0015]

  % 現在、元となる型との演算も提供している。
  % しかし polynomial<rational<int>> などとした場合に、
  % 元となる型の更に元となる型との演算をできるようにしなければ不便である。
  %
  % 係数体の更に元となる型との演算を特別に実装するのは大変である。
  % 様々な組み合わせが考えられるからである。
  % 従って、元となる型の更に元となる型の値 value1 との演算は、
  % 一旦 value1 から元となる型を構築してから行う事になる。
  %
  % 実装上の都合から整数 (int) 0 や 1 などとの比較や構築は頻繁に起こる。
  % これらに関しては特別に直接の比較ができるように実装するのが良い。
  % また、実際に元になる型の chain に int が含まれていなかったとしても、
  % int から K への変換は提供して然るべきである。

  或いは、underlying_type からの implicit conversion を義務付ける事にしておけば、
  判定は is_convertible (implicitly convertible かどうかの判定) でできる。
  こちらの方が自然な様に思われる…。

  実は実装してみた所 int を用いて直接演算をする場合と、
  K を用いて直接演算をする場合は処理の形としては全く同じである。
  int として計算を行うか K として計算を行うかの違いしか無い。
  考えてみればそれもそのはずである。親クラスは元の型の詳細を知らないのだから、
  結局できることは、親クラスを構築せずに演算をするということで、
  int と K を区別する様な記述の仕方はないのである。
  そして K が int と相互に演算可能である以上は特別な配慮も要らない。

  結果として、K と int の実装は統一する事にする。
  そして is_convertible で様々な型の値を受け取れる様にする。
  is_convertible が一方向になっている限りは overload 解決で問題になる事もあるまい。

2017-01-06

* Gauss-Chebyshev を実装した [#D0014]

  実際にこれを使って計算をしてみるとそんなに収束は良くない。
  恐らく $\sqrt{1-x^2} f(x)$ が多項式近似でうまく表せなければ性能が悪いのだろう。
  $\sqrt{1-x^2}$ は $x \sim \pm1$ での振る舞いが激しい。傾きが発散する。
  Gauss Chebyshev を使うならば橋での振る舞いが激しい関数でないとよくなさそう。

  実際に f = 1/sqrt(1-x^2) の場合には次数 1 から厳密な値を返し、
  次数を増やしても結果は変わらない。

2016-12-19

* 2016-12-13 取り敢えずいま準備できる物 [#D0013]

  > - Runge-Kutta
  > - 線形方程式解法
  > - Gauss-Legendre quadrature
  >
  > 取り敢えず既存のファイルについては持ってきた。

  これらについて使い方を整理する。

  > また、実際にこれを使ったコードを用意しないと発展しないので、
  > bolt の側を libkashiwa を用いる様に書き換える。

* 2016-12-16 線形フィッティングのコード [#D0012]

  線形フィッティングは基本的には射影である。

    R^2 = (y - ∑ Ai fi)^2

  を最小化するというのは ${f_i}$ で貼られる部分空間に $y$ から垂線を下ろすという事である。
  垂線の長さが R であり、足の座標が $A_i$ である。

    y ->  Py = ∑_{ij} f_i (f_i \cdot f_j)^-1 f_j \cdot y

  実際以下の様になっているのでこれは射影である。

    P^2 = f_i (f_i \cdot f_j)^-1 f_j \cdot f_k (f_k \cdot f_l)^-1 f_l
      = f_i (f_i \cdot f_j)^-1 f_j = P
    P f_m = ∑_{ij} f_i (f_i \cdot f_j)^-1 f_j \cdot f_m
      = ∑_i f_i δ_{im} = f_m

  さて A_i の係数はどの様に読み取れるかと言うと、

    A_i = (f_i \cdot f_j)^-1 f_j \cdot y

  である。

  線形フィッティングのコードを書いたが、
  それを利用する側のコードを記述しなければならない。
  現在 bolt では計算結果を全て外に出力する様になっている。

  ところでその前にガウス求積のインターフェイスを何とかしなければならない。
  ガウス求積のインターフェイスは更新した。
  bolt から線形フィッティングの機能を呼び出す。
  見た感じ期待通りに動いている様子である。
  # ただし bolt の側で beta がとても小さいときに結果が滅茶苦茶になっている。
  # これは bolt の側の数値計算上の問題であるのでここでは関係ない。

2016-12-16

* ガウス求積のインターフェイス [#D0011]

  - 現在のガウス求積の interface ではスカラーの値しか積分できない。
    複数の数値・もしくはベクトルを積分できる様にする。

* 2016-12-15 線形方程式解法に関して [#D0010]

  現在の実装方法だと何回もメモリを確保したり開放したりという事になる。
  LU分解専用のバッファを用意して更に std::move を使ったり使わなかったり
  で動作が異なる様に実装するのが良いように思われる。

  更に元々の配列を破壊しても良い場合には更に使用メモリを削減する事ができる。

  →working_buffer を受け取ってその中で必要な領域を全て確保する様に変更した。
    更に様々な場合を想定して引数を増やした。
    入力用の配列と受取用の配列が一致している時に従来の動作 (配列を書き換える) と一致する。

2016-12-13

* runge_kutta: bolt の filter [#D0009]

  bolt の側も filter-branch して Runge-Kutta を除くか?
  bolt の側では kashiwa を使う様に変更してから
  使わなくなった歴史を削除する様にすれば良い。

  と思ったが、よく考えてみれば bolt は embedded_runge_kutta.h
  その他に依存しているので embedded_runge_kutta.h etc を削除すると
  過去の version が動かなくなってしまう。
  embedded_runge_kutta.h etc 側がその他の部分に依存していなかったのと対照的である。
  従って bolt の側では過去の erk 類の歴史の改変は行わずに、
  現在の状態からファイルを削除するという様に留めて置くのが懸命である。

  取り敢えず bolt を kashiwa を使ってコンパイルする様に変更し、
  bolt に含まれていた対応するファイルたちを削除した。


* runge_kutta: memo.txt, Makefile 取り込み [#D0008]

  よく考えたらこれを merge するのを忘れていた。

* runge_kutta: Runge-Kutta 取り込み [#D0007]

  Runge-Kutta に関しては bolt repository から取り込む。
  関連する commit だけを抽出する方法について調べる。
  うーん。先ず初めに filter-branch --tree-filter で
  関係ないファイルを全て削除してそれから空のコミットを squash すれば良いのだろうか。

    $ g log --name-status | sed -n 's/^[A-Z]\b[[:space:]]*//p' | sort -u > list.txt

  とすると過去のファイル名一覧が出てくるのでそれを見て残したファイル名を削除する。
  そして、そのファイル名を使って filter-branch を実行する。
  Makefile, memo.txt に関しては使う部分もあるが不要な部分もあるだろう。
  これらに関しては取り敢えず削除しておいて後で必要な部分を pick up する。

    $ g filter-branch --tree-filter 'rm -rf $(< remove-list.txt)'

  取り敢えずはうまく行っている。そして沢山の空のコミットが残っている。これらはどの様に squash すれば良いのか。
  この方法がよく分からないと思ったが filter-branch --commit-filter の skip_commit を使えば良いらしい。
  しかし filter-branch の最中に現在のコミットが変更のないコミットなのかどうか調べる方法はあるのか。
  どうやら引数に commit id が与えられる様であるのでそれを用いて

    % git filter-branch --commit-filter '
    %   if [[ $(git log --name-status $1 | grep '^[A-Z]\b') ]]; then
    %     skip_commit "$@"
    %   else
    %     git commit-tree "$@"
    %   fi'

  とかやれば良いのだろうか。よく分からないので実際に試す必要があるだろうか。
  と思っていたら filter-branch の help に git_commit_non_empty_tree という物の説明がある。

    https://www.kernel.org/pub/software/scm/git/docs/git-filter-branch.html

  という事は単に

    $ g filter-branch --commit-filter 'git_commit_non_empty_tree "$@"'

  で良いという事なのだろうか。試してみる事にする。うまく行ったので OK.

  改めて repository を観察してみると submodule (ext/getopt) が削除できていない。
  --tree-filter 'rm -rf ext/getopt' では不十分な様だ。検索してみると

    http://stackoverflow.com/questions/23207104/git-filter-branch-remove-all-submodules-from-my-repo

  にその物が書かれている。さて、これの回答を見ると --prune-empty というオプションがついている。
  これについて調べてみると、空になったコミットは自動で削除してくれる様である。

    [git filter-branchで過去の全てのcommitから画像ファイルの追加/変更をなかったことにしてリポジトリを軽量化する - dskd](http://dskd.jp/archives/46.html)

  つまり、わざわざ後で squash/git_commit_non_empty_tree を実行する必要はなかったのだ。

    $ git filter-branch -f --prune-empty --tree-filter '
    $   git submodule deinit -f .
    $   git rm -rf ./ext/getopt && rm -rf ./ext
    $   find . -name .gitmodules -delete'

  何か色々とエラーが出たような気がするが気にしない。更に、
  すべてのファイルの歴史をサブディレクトリ src 内に移動したい。
  これはできるのだろうか。

    [Gitリポジトリのディレクトリ構成を変更する - ekreaの日記](http://d.hatena.ne.jp/ekrea/20120819/1345401248)

  を参考にして試してみる。

    % git filter-branch -f --tree-filter 'mkdir src; mv *.* bflow ksh src/'

  エラーが出て出来ない。仕方がないので丁寧に書くことにする。

    $ git filter-branch -f --tree-filter '
    $   mkdir -p src
    $   a=()
    $   for f in *.* bflow ksh; do
    $     [[ -e $f ]] && a+=("$f")
    $   done
    $   if ((${#a[@]})); then
    $     mv -f "${a[@]}" src
    $   fi'

  できた。後はくっつけるだけである。

    [kashiwa]$ g checkout --orphan rk-merge
    [kashiwa]$ g pull ../bolt-rk-2 master
    [kashiwa]$ g checkout master
    [kashiwa]$ g merge rk-merge

  何事もなく終わった。

* 取り敢えず作る。計画を立てる [#D0006]

  今までに書いたコード、それからこれから書く数値計算関連のコードに関して、
  便利で汎用的な物を全部ここに放り込んでいく事にする。

  実の所、殆ど車輪の再発明になる様な気がするが学習の為、
  モチベーションの為という事にする。

  既に書いたコードとしては Runge-Kutta 等があるが
  これはボルツマンのコードの方に記録されている。
  また線形方程式を LU 分解を用いて解くコードに関しては、
  rfh の方で書いてそれがボルツマンの方にも流用されている。

  また、線形フィッティングに関してはボルツマンの方で使いたいので、
  こちらで実装する事にしたい。

  更に Gauss quadrature に関してもまとめて置きたい。
  ゼロ点を正しく求める為には多倍長演算も欲しい。
  しかしこれは今の所使う予定はないので後で考えておく。


2016-04-25

* runge_kutta: DOP853 を改造して途中で状態を出力するなどの処理をできる様にする [#D0005]

  DOP853 では誤差に応じた h の変更なども含めて目的の時刻まで積分を実行する物なので、
  現在の様に時間微分の関数 f だけを渡す様な設計だと時間発展以外に何も出来ない。
  したがって、関数 f を渡す代わりに "方程式" と称して様々な事を
  実行する様なクラスインスタンスを渡す様にする必要がある。

2016-04-24

* runge_kutta: Runge-Kutta について思うこと [#D0004]

  様々な種類の RK がある。どの次数を選ぶのが良いか。

  - 色々試してみるに高次であれば高次である程良い気がする。
  - 但し、問題が高階微分可能である場合に限られるのは当然である。
  - 時間微分の見た目自体が解析であっても、変数が場で不連続 (衝撃波) を持つ場合は時間微分ができなくなる。
    実際には空間の離散化をすると不連続性はない様に思われるが、
    空間の離散化をする前に、ルンゲクッタ化・及び不連続性の評価をして、
    その後で空間の離散化をしなければ物理的に正しい結果を得られない
    (これは 2016-04-24 の考察を参照のこと) ことに注意する。

  - http://www.ipc.akita-nct.ac.jp/yamamoto/lecture/2003/5E/lecture_5E/diff_eq/node2.html

    このページは可成り間違っていることばかり書かれている。

    | 検索すると「4 次以降は同じ段数が余分に必要だからコストが高く実際は4次しか使えない」
    | 「5次のRunge-Kuttaなど見た事ない」等と頭の悪いことを書いている人がいて、
    | 更にそれを引用している人達が沢山居てどうしようもない事になっているがこれは完全に誤りである。
    |
    | 実際に数値計算をしてみれば大抵の問題ではやはり高次である方が良いし、
    | また、実際に8次RKなどは高精度・長期間の天体の軌道計算では常用されている様だ。

    上記の文章でやり玉に挙げているのは実はこのページである。
    更に気になることが最後に書かれている。

    > ただし、4次のルンゲ・クッタ法よりも精度の良い方法がないわけでは有りません。
    > より高精度な方法として、Bulirsch-Store法や予測子・修正法などがあります。

    Bulirsch-Store法とは何のことかと思ったらリチャードソン補外の GBS 法の事である。
    でも GBS には基礎として低次のルンゲクッタを用いる。

    また予測子・修正子がここで出て来るのは謎である。これは陰的解法を近似するための方法の筈で、
    元の陰的解法を指定しなければ何のことだか分からない。陰的RKに適用しようとすると結局陽的RKに等価なので、
    だとすればこれは AB 法の類の予測子・修正子のことを言っているのだろう。
    しかしながらアダムスの方法は元より不安定であるし、更に 6 次を超えると不安定になって全く何も解けないらしい。
    高精度の方法として紹介される理由が不明である。

  各次数において複数の RK 法が大体あるがどれを選ぶのがよいのだろうか。
  - 調べてみると予想通り方程式によって良い方法という物が変わるようだ。
  - 物によっては丁度ぴったり高次の項が再現されて次数自体が実効的に上昇することもある。
  - しかしそれでも性能には大体の傾向がある様だ。眺めてみるとどうやら節点が均等に分布されていて、
    重みが対称でかつ真ん中に重みがある (積分公式に類似) ような物が性能がよいようである。


  RKの他にもABなどあるが結局どれを選べばよいのか。
  - ハイラーの本によるとさすが数値比較を沢山の問題に対して適用していて、
    結局自動ステップ幅制御は必須で、更に DOP853 が実際の計算時間で他を完全に引き離している。


2016-04-12

* runge_kutta: 結局、取り敢えずは RKG を使うのが良さそうである [#D0003]

  計算結果が安定でない場合には TVD RK4 を何處からか探してきて適用する必要がある。
  或いは、TVD RK4 にすると微妙なうねりが減るとかそういう事もあるかもしれないので、
  観察してみる価値はあるかもしれない。何れにしてもまずは RKG である。

2016-04-22

* runge_kutta: CV8 の丸め誤差が蓄積する [#D0002]

  分割数を更に多くして確かめてみた所 RK4 の丸め誤差は一定に留まっているのに対して、
  CV8 の丸め誤差は線形で成長している。何故だろうか。
  CV8 の係数に丸め誤差が含まれている所為かと考えて、
  係数は bc で高精度に計算する様にしてみたが変わらない。

  というかそもそも線形で丸め誤差が成長するのは自然な事ではないのか。
  いや、或いは方程式に依存する筈であるが、丸め誤差は成長してもおかしくない。
  では、何故 RK4 では丸め誤差が成長しないのだろうか。
  そう思って、初期条件の値に 1e-15 の誤差を手で入れて試してみると、
  RK4 でも誤差が少しずつ成長する様になった。
  たまたま蓄積する丸め誤差が打ち消すような
  そういう初期条件になっていたということだろうか。
  また、初期条件に誤差を混入したら CV8 の方は
  逆に丸め誤差の蓄積が緩やかになったような気もする。

  結論: これは仕方がない。寧ろ RK4 で誤差が蓄積していないのが偶然。

2016-04-22

* runge_kutta: Runge-Kutta Gill [#D0001]

  Runge-Kutta Gill は丸め誤差をキャンセルする様にできているのだと言っておきながら、
  他の4段4次の公式と較べて大して違いがある様には見えない。
  ただ、使用メモリ量が少なくて済むのは嬉しい事である。
  計算コストの方はどうなのだろうか。

  x どうも同じ 4次 RK でも手法によって誤差の比例係数の大きさに傾向がある様だ。
    勿論、解く問題によって状況は異なるのは当然だが、Kutta 3/8 が多くの場合で良い。
    Gill は次点である。古典的公式よりは良い結果を与える場合が多い。
    (そういう意味で古典的公式を使う利点はただ有名だからという以外にないようだ。)

  - また、微分 f を計算するのに一番コストがかかるという場合を考えるのだとすれば、
    Runge-Kutta プロセスで多少メモリを食おうが何しようが無視できる。

  - 他の公式と較べて (最低) メモリ使用量が 3/4 になるだけなので、
    実際の所それが丁度 CPU のキャッシュに乗り切るかどうかの分水嶺になるというケースは稀であろう。
    しかも、どうせデータはシーケンシャルに舐めるのでキャッシュに載ろうがどうだろうが
    (メモリコントローラが充分賢ければ) 余り関係ない。キャッシュにプリフェッチされる。

  何れにしても机上で考えても実際のところは分からない。
  様々な問題について実測してみないと確かなことは分からない。
